\chapter{Аналитический раздел}

В данном разделе будет кратко описана история создания алгоритма DES, будет приведено его формально описание, а также будет формально описан режим шифрования PCBC.

\section{История создания алгоритма DES}

Стандарт шифрования данных (DES) - блочный шифр с симметричными ключами, разработан Национальным Институтом Стандартов и Технологии (NIST - National Institute
of Standards and Technology).

В 1973 году NIST издал запрос для разработки предложения национальной криптографической системы с симметричными ключами. Предложенная IBM модификация проекта, названная Lucifer, была принята как DES. DES был издан как FIPS 46 в Федеральном Регистре в январе 1977 года.
FIPS объявил DES как стандарт для использования в неофициальных приложениях. Позже NIST предложил новый стандарт (FIPS 46-3), который рекомендует использование тройного DES (трехкратно повторенный шифр DES) для будущих приложений.

\section{Общие положения алгоритма DES}

Общие положения алгоритма DES:

\begin{enumerate}
	\item на стороне шифрования DES принимает 64-битовый исходный текст и порождает
	64-битовый зашифрованный текст;
	\item на стороне дешифрования DES принимает 64-битовый зашифрованный текст и порождает 64-битовый исходный текст;
	\item на обеих сторонах для шифрования и дешифрования применяется один и тот же
	56-битовый ключ.
\end{enumerate}

\section{Алгоритм DES}

Общее описание алгоритма:

\begin{itemize}
	\item исходный текст - блок 64 бит;
	\item процесс шифрования состоит из начальной перестановки, 16 циклов шифрования (раундов Фейстеля) и конечной перестановки;
	\item каждый раунд использует различные сгенерированные 48-битовые ключи.
\end{itemize}

На рисунке \ref{img:DES_algorithm_scheme} представлена схема шифрования алгоритма DES:

\includeimage
{DES_algorithm_scheme} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Схема шифрования алгоритма DES} % Подпись рисунка

Начальная и конечная перестановки в основном служат для облегчения побайтовой загрузки данных открытого текста и шифротекста в микросхему DES (DES появился раньше 16- и 32-битовых микропроцессорных шин).

Каждая из перестановок принимает 64-битовый вход и переставляет его элементы по заданному правилу. Эти перестановки - прямые перестановки без ключей, которые инверсны друг другу. Значение каждого элемента определяет номер входного порта, а порядковый номер (индекс) элемента определяет номер выходного порта.

На рисунках \ref{img:IP} и \ref{img:IP-inv}  представлены таблицы начальной и конечной перестановок:

\includeimage
{IP} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Начальная перестановка $IP$} % Подпись рисунка

\includeimage
{IP-inv} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Конечная перестановка $IP^{-1}$} % Подпись рисунка

\subsection{Раунды шифрования}

Полученный после начальной перестановки 64-битовый блок $IP(T)$ участвует в 16 раундах преобразования Фейстеля.

Раунд шифрования:

\begin{enumerate}
	\item разбить $IP(T)$ на две части $L_0$ и $R_0$, где $L_0$ и $R_0$ соответственно 32 старших битов и 32 младших битов блока $T_0$ $IP(T) = L_0 R_0$;
	\item пусть $T_{i-1} = L_{i-1}R_{i-1}$ -- результат $i-1$ итерации, тогда результат $i$-ой  итерации $T_{i} = L_{i}R_{i}$ определяется по формуле \ref{eq:round};
	
	\begin{equation}
		\label{eq:round}
		\begin{aligned}
			L_i &= R_{i-1} \\
			R_i &= L_{i-1} \oplus f(R_{i-1}, k_i)
		\end{aligned}
	\end{equation}
	\item в 16-ти раундах преобразования Фейстеля функция $f$ играет роль шифрования.
\end{enumerate}

На рисунке \ref{img:f_encrypt} представлена схема работы одного раунда шифрования:

\includeimage
{f_encrypt} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Прямое преобразование сетью Фейстеля} % Подпись рисунка

\subsection{Функция Фейстеля}

Аргументами функции $f$ являются 32-битный вектор $R_{i-1}$ и 48-битовый ключ $k_i$, который является результатом преобразования 56-битового исходного ключа шифра $k$. Для вычисления значения  функции $f$ последовательно используются: 

\begin{enumerate}
	\item функция расширения $E$;
	\item XOR с ключом $k_i$;
	\item преобразование $S$, состоящее из 8-ми преобразований $S$-блоков $S_1, S_2, S_3, \ldots S_8$;
	\item перестановка P.
\end{enumerate}

Функция $E$ расширяет 32-битовый вектор $R_{i-1}$ до 48-битового вектора $E(R_{i-1})$ путём выполнения следующих действий:

\begin{enumerate}
	\item 32-битовый вектор $R_{i-1}$ делится на 8 блоков по 4 бита каждый;
	\item в каждый блок слева добавляется крайний правый бит предыдущего блока, а справа -- крайний левый бит следующего блока;
	\item в качестве бита слева для первого блока выступает крайний правый бит последнего блока, а для бита справа для последнего блока -- крайний левый бит первого блока.
\end{enumerate}

Порядок битов указан на рисунке \ref{img:E}.

\includeimage
{E} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.3\textwidth} % Ширина рисунка
{Функция расширения $E$} % Подпись рисунка

Полученный после перестановки блок $E(R_{i-1})$ складывается по модулю 2 с ключом $k_i$ и представялется в виде 8-ми последовательных блоков $B_1, B_2, B_3, \ldots B_8$ каждый по 6 бит (формула \ref{eq:e}).

\begin{equation}
	\label{eq:e}
	\begin{aligned}
		E(R_{i-1}) \oplus k_i &= B_1, B_2, B_3, \ldots B_8
	\end{aligned}
\end{equation}

Каждый $B_j$ является  6-битовым блоком. Далее, каждый из блоков $B_j$ трансформируется в 4-битовый блок $B^{'}_{j}$ c помощью преобразования $S_i$ \cite{info_DES}.

Значение функции $f(R_{i-1}, k_i)$ получается перестановкой $P$, применяемой к 32-битному блоку $B^{'}_1, B^{'}_2, B^{'}_3, \ldots B^{'}_8$ (формула \ref{eq:e2}).

\begin{equation}
	\label{eq:e2}
	\begin{aligned}
		f(R_{i-1}, k_i) &= P(B^{'}_1, B^{'}_2, B^{'}_3, \ldots B^{'}_8)
	\end{aligned}
\end{equation}

Таблица перестановки $P$ указана на рисунке \ref{img:P}.

\includeimage
{P} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.3\textwidth} % Ширина рисунка
{Перестановка $P$} % Подпись рисунка

\subsection{Генерация ключей ki}

Ключ $k$ представляет собой 64-битовый блок с восемью битами контроля по четности, расположенными в позициях 8,16,24,32,40,48,56,64. Для удаления контрольных битов и перестановки остальных используется функция $G$ первоначальной подготовки ключа (рисунок \ref{img:P-ki}).

\includeimage
{P-ki} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.7\textwidth} % Ширина рисунка
{Перестановка первоначальной подготовки ключа} % Подпись рисунка

Результат преобразования $G(k)$ разбивается на два 28-битовых блока $C_0$ и $D_0$, причем $C_0$ будет состоять из битов 57, 49, ..., 44, 36 ключа $k$, а $D_0$ будет состоять из битов 63, 55, ..., 12, 4 ключа $k$. 

После определения $C_0$ и $D_0$ рекурсивно определяются $C_i$ и $D_i$, $i=1\ldots16$. Для этого применяют циклический сдвиг влево на один или два бита в зависимости от номера итерации (рисунок \ref{img:P2-ki}).

\includeimage
{P2-ki} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.7\textwidth} % Ширина рисунка
{Сдвиги для вычисления ключа} % Подпись рисунка

Ключ $k_i$, $i=1\ldots16$ состоит из 48 бит, выбранных из вектора $C_iD_i$ согласно рисунку \ref{img:P3-ki}.

\includeimage
{P3-ki} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.7\textwidth} % Ширина рисунка
{Завершающая обработка ключа} % Подпись рисунка

Первый и второй биты ключа $k_i$ есть биты 14, 17 вектора $C_iD_i$.

\section{Расшифрование}

При расшифровании данных все действия выполняются в обратном порядке. В 16 циклах расшифрования, в отличие от шифрования c помощью прямого преобразования сетью Фейстеля, здесь используется обратное преобразование сетью Фейстеля:

\begin{equation}
	\label{eq:round}
	\begin{aligned}
		R_{i-1} &= L_{i} \\
		L_{i-1} &= R_{i} \oplus f(L_{i}, k_i)
	\end{aligned}
\end{equation}

На рисунке \ref{img:f_decrypt} представлена схема работы одного раунда расщифрования:

\includeimage
{f_decrypt} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Обратное преобразование сетью Фейстеля} % Подпись рисунка

Ключ $k_i$, $i=16\ldots1$ такие же, как и в процессе шифрования. Функция $f$, перестановка $IP$ и $IP^{-1}$ такие же, как и в процессе шифрования. Алгоритм генерации ключей зависит только от ключа пользователя, поэтому при расшифровании они идентичны.

\section{Режим шифрования PCBC}

Для шифрования некоторого сообщения $P$ выполняются следующие действия:

\begin{enumerate}
	\item сообщение разбивается на блоки одинакового размера. Размер (длина) блока равен $n$ и измеряется в битах. При необходимости последний блок дополняется до длины $n$;
	\item шифрование очередного ($i$-го) блока сообщения $P_i$ выполняется с использованием предыдущего  блока открытого текста и предыдущего блок шифротекста  после применения операции XOR над ними. Для первого блока ($P_1$) зашифрованного блока не существует, поэтому первый блок шифруют с использованием <<вектора инициализации>> $IV$ (формула \ref{eq:pcbc_enc});
	
	\begin{equation}
		\label{eq:pcbc_enc}
		\begin{aligned}
			C_0 &= IV \\
			C_i &= E_k(P_{i-1} \oplus C_{i-1} \oplus P_{i}, k)
		\end{aligned}
	\end{equation}
	
	\item расшифорвание очередного ($i$-го) блока сообщения происходит по формуле \ref{eq:pcbc_dec}.
	
	\begin{equation}
		\label{eq:pcbc_dec}
		\begin{aligned}
			C_0 &= IV \\
			P_i &= D_k(C_{i}, k) \oplus C_{i-1} \oplus P_{i-1}
		\end{aligned}
	\end{equation}
\end{enumerate}

На рисунке \ref{img:PCBC} представлена схема режима шифрования PCBC.
\includeimage
{PCBC} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Схема режима шифрования PCBC} % Подпись рисунка

\section*{Вывод}

В данном разделе была кратко описана история создания алгоритма DES, было приведено его формально описание, а также был формально описан режим шифрования PCBC.